# План разработки Telegram-бота “PillsReminderBot”

Цель: бот в Telegram, который умеет создавать напоминания:
- ежедневные напоминания в заданное время;
- напоминания **несколько раз в день** в заданном **временном интервале**.
Доп. правило для приёма: если наступило время приёма, бот **повторяет напоминание каждые 2 часа**, пока пользователь не отметит, что таблетки выпил.

---

## Статус выполнения

- [x] **Итерация 0 — подготовка проекта** (Generic Host, long polling, чтение `BOT_TOKEN`, сборка OK)
- [x] **Итерация 1 — база: /start, /timezone** (SQLite+EF Core, callback queries, сохранение таймзоны, сборка OK)
- [x] **Итерация 2 — CRUD напоминаний** (MVP: `/new HH:mm текст`, `/list`, `/delete`)
- [x] **Итерация 3 — планировщик и доставка** (повтор каждые 2 часа до “✅ Выпил”)
- [x] **Итерация 4 — “несколько раз в день в интервале”** (MVP: `/newi`, расчёт следующего приёма)
- [x] **Итерация 5 — полировка и прод-готовность** (enable/disable, локальное время, env vars)

---

## 1) Уточнение требований (минимум перед кодом)

- **Часовой пояс**: напоминания должны срабатывать по времени пользователя (а не сервера). Способ задания:
  - авто (по Telegram недоступно надёжно) → нужен явный выбор: `UTC+3`, `Europe/Moscow`, и т.п.
- **Формат “несколько раз в день”** (выбрать один и зафиксировать):
  - **A. Каждые N минут** в интервале (например, 09:00–21:00 каждые 180 минут).
  - **B. N раз в день** равномерно в интервале (например, 3 раза между 09:00–21:00).
  - **C. Набор фиксированных времён** в течение дня (например, 09:00, 14:00, 21:00).
  - Рекомендация для MVP: поддержать **A** и **C**, “B” можно добавить позже.
- **Повторяемость**: только “каждый день” или нужна периодичность “каждые N дней/по дням недели”.
- **Срок действия**: бесконечно / до даты / количество срабатываний.
- **Уведомление**: только текст или ещё кнопки “✅ Принял / ⏰ Отложить”.
- **Групповые чаты**: поддержка личных сообщений vs группы (в MVP — личка).

### Правило подтверждения приёма (зафиксировано)
- При наступлении времени приёма бот отправляет сообщение с кнопкой **“✅ Выпил”**.
- Пока пользователь не нажмёт **“✅ Выпил”**, бот повторяет это же напоминание **каждые 2 часа**.
- После подтверждения:
  - для ежедневных напоминаний планируется следующий приём (на следующий день / следующее расписание);
  - повтор “каждые 2 часа” прекращается.

---

## 2) Технологический стек (предложение для .NET проекта)

- **Telegram API**: пакет `Telegram.Bot`.
- **Хостинг и фоновые задачи**: `Microsoft.Extensions.Hosting` (Generic Host) + `BackgroundService`.
- **Хранение данных (MVP)**: SQLite + EF Core (`Microsoft.EntityFrameworkCore.Sqlite`).
- **Планировщик** (варианты):
  - **MVP**: собственный “тикер” раз в 10–30 секунд, выбирающий из БД задачи `NextFireAt <= now`.
  - **Прод**: Quartz.NET или Hangfire (если нужен удобный management).
- **Логи**: `Microsoft.Extensions.Logging` + console.
- **Конфигурация**: `appsettings.json` + env vars (Docker).

---

## 3) Архитектура и структура проекта

Рекомендуемая структура папок:
- `Bot/`
  - `BotUpdateHandler.cs` (обработка апдейтов)
  - `Commands/` (роутинг команд /start, /new, /list, /delete, /timezone)
  - `Flows/` (диалоги/сцены создания напоминания)
- `Domain/`
  - `Reminder.cs`, `ReminderSchedule.cs`, `UserProfile.cs`
  - enum’ы `ReminderType`, `ReminderStatus`
- `Persistence/`
  - `AppDbContext.cs`, migrations
  - репозитории (опционально)
- `Scheduler/`
  - `ReminderSchedulerService.cs` (BackgroundService)
  - расчёт `NextFireAt` и обработка “просроченных” запусков
- `Infrastructure/`
  - время/таймзона (`TimeProvider`, `ITimeZoneProvider`)
  - idempotency / дедупликация (по необходимости)

Основная идея: **БД хранит “истину”**, а планировщик регулярно:
1) находит напоминания, которые должны сработать;
2) отправляет сообщение;
3) пересчитывает `NextFireAt`.

---

## 4) Модель данных (MVP)

### Таблица `UserProfiles`
- `Id` (PK)
- `TelegramUserId` (unique)
- `ChatId` (куда отправлять)
- `TimeZoneId` (например, `Europe/Moscow` или фиксированное `UTC+03:00`)
- `CreatedAt`, `UpdatedAt`

### Таблица `Reminders`
- `Id` (PK)
- `TelegramUserId` (FK/индекс)
- `Title` (например “Витамин D”)
- `Message` (текст напоминания; можно = Title)
- `Type`:
  - `DailyAtTime`
  - `EveryNMinutesInWindow`
  - `FixedTimesInWindow` (если делаем вариант C)
- **Поля для расписания** (зависит от `Type`):
  - `DailyTime` (HH:mm)
  - `WindowStart` (HH:mm), `WindowEnd` (HH:mm)
  - `EveryMinutes` (int)
  - `TimesJson` (для набора времён, если нужно)
- `IsEnabled` / `Status`
- `NextFireAtUtc` (ключевое поле для планировщика)
- `LastFiredAtUtc` (для аудита/отладки)
- `StartDate`/`EndDate` (опционально)
- `CreatedAt`, `UpdatedAt`

Индексы:
- по `NextFireAtUtc`
- по `TelegramUserId`

---

## 5) UX: команды и диалоги (MVP)

### Команды
- **/start**: приветствие, краткая справка, предложение настроить часовой пояс.
- **/timezone**: выбор часового пояса (кнопки с популярными вариантами + ввод вручную).
- **/new**: создание напоминания (пошагово).
- **/list**: список напоминаний с ID и кратким расписанием.
- **/delete <id>**: удалить.
- **/disable <id>** / **/enable <id>**: опционально.

### Диалог создания (/new)
Шаги:
1) Название/текст напоминания.
2) Тип расписания:
   - “Каждый день в одно время”
   - “Несколько раз в день (в интервале)”
3) Для “каждый день”:
   - ввод времени `HH:mm`
4) Для “в интервале” (вариант A):
   - ввод `начало HH:mm`, `конец HH:mm`
   - ввод “каждые N минут/часов”
   - валидация: конец > начало, N > 0, разумные лимиты
5) Подтверждение → запись в БД → показать краткое резюме.

Важные UX детали:
- все вводы валидировать и просить повторить при ошибке;
- показывать пример формата (`09:30`);
- использовать inline-кнопки для выбора типа, подтверждения, отмены.
- в уведомлении о приёме показывать кнопку **“✅ Выпил”** (останавливает повтор каждые 2 часа).

---

## 6) Планировщик (логика срабатываний)

### Общий подход (MVP)
- `ReminderSchedulerService` запускается в фоне.
- **Раз в 2 часа**:
  1) берёт текущее время `nowUtc`;
  2) выбирает пачку `NextFireAtUtc <= nowUtc` (например, до 100 штук);
  3) отправляет сообщения;
  4) пересчитывает следующий запуск и обновляет запись.

Примечание:
- При опросе раз в 2 часа напоминания могут приходить **с задержкой до 2 часов** относительно целевого времени.
- Логика “повторять каждые 2 часа до подтверждения” естественно ложится на такой опрос: каждое срабатывание планировщика отправляет уведомление и сдвигает `NextFireAtUtc` на `nowUtc + 2h`, пока нет подтверждения.

### Пересчёт `NextFireAt`
- Всегда считать на основе **таймзоны пользователя**:
  - `nowLocal = Convert(nowUtc, tz)`
- Для `DailyAtTime`:
  - следующий запуск = ближайшая дата/время `DailyTime` в будущем (локально), затем конвертация в UTC.
- Для `EveryNMinutesInWindow`:
  - внутри дня: если сейчас до окна → следующий = сегодня `WindowStart`
  - если в окне → следующий = nowLocal + N минут (но не позже `WindowEnd`)
  - если после окна → следующий = завтра `WindowStart`
  - всё в UTC хранить в `NextFireAtUtc`.

### Надёжность
- При рестарте бота расписание восстанавливается из БД.
- Если бот “проспал” (сервер был выключен), поведение для MVP:
  - отправлять **только ближайшее** пропущенное (или пропускать) — выбрать правило и зафиксировать.

---

## 7) Безопасность и ограничения

- Ограничить число напоминаний на пользователя (например 100).
- Ограничить частоту “каждые N минут” (например минимум 15 минут) — чтобы не спамить.
- Хранить токен бота только в env vars/секретах, не в репозитории.

---

## 8) Этапы разработки (итерациями)

### Итерация 0 — подготовка проекта
- [x] Подключить `Telegram.Bot`, `Microsoft.Extensions.Hosting`, логирование, конфиг.
- [x] Переписать `Program.cs` на Generic Host:
  - [x] чтение `BOT_TOKEN`
  - [x] запуск long polling
  - [x] graceful shutdown
- Результат: бот отвечает на `/start` и делает echo-сообщения (тест связи).

### Итерация 1 — база: /start, /timezone
- [x] Реализовать обработку апдейтов (сообщения, callback queries).
- [x] Модель `UserProfile` + SQLite/EF Core.
- Команда `/start`, выбор часового пояса, сохранение в БД.

### Итерация 2 — CRUD напоминаний
- `/new` (диалог) → создание `DailyAtTime`.
- `/list` → вывод.
- `/delete <id>` → удаление.

### Итерация 3 — планировщик и доставка
- `ReminderSchedulerService`:
  - выбор due напоминаний
  - отправка сообщений в chatId
  - расчёт `NextFireAtUtc`
- Метрики/логи: сколько напоминаний обработано за тик (тик = раз в 2 часа).

### Итерация 4 — “несколько раз в день в интервале”
- Добавить `EveryNMinutesInWindow` (и/или фиксированные времена).
- Валидации, UX подсказки.
- Тестирование сценариев: границы окна, переход суток, таймзоны.

### Итерация 5 — полировка и прод-готовность
- Команды enable/disable.
- Обработка ошибок Telegram API (429, сетевые сбои) + backoff.
- Docker: env vars, volume для SQLite.
- Документация: `README.md` (как запускать локально и в Docker).
- Улучшение UX: показывать время напоминаний и следующий запуск в локальном времени пользователя (а не в UTC).
- Настройки для тестов/прод: `SCHEDULER_POLL_SECONDS`, `REPEAT_UNTIL_ACK_MINUTES`.

---

## 9) Критерии готовности (Definition of Done)

- Пользователь может:
  - задать таймзону;
  - создать ежедневное напоминание;
  - создать напоминание “несколько раз в день в интервале”;
  - посмотреть список и удалить напоминания.
- После рестарта бота напоминания продолжают работать.
- Время срабатывания корректно для таймзоны пользователя.
- Нет хранения токена в репозитории; запуск через env var `BOT_TOKEN`.

---

## 10) Вопросы к вам (чтобы зафиксировать точные правила)

1) Формат “несколько раз в день” — выбираем **каждые N минут** (A) или **фиксированные времена** (C) или оба?
2) Нужно ли “по дням недели” (Пн/Ср/Пт) или пока только “каждый день”?
3) Что делать с пропущенными напоминаниями, если бот был выключен: отправлять при запуске или пропускать?
4) Подтверждение “принял” / “отложить” нужно в MVP?


